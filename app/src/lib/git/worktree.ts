import * as Os from 'os'
import * as Path from 'path'
import * as FSE from 'fs-extra'

import { git } from './core'

import { Repository, LinkedWorkTree } from '../../models/repository'
import { getMatches } from '../helpers/regex'

/** Enumerate the list of work trees reported by Git for a repository */
export async function listWorkTrees(
  repository: Repository
): Promise<ReadonlyArray<LinkedWorkTree>> {
  const result = await git(
    ['worktree', 'list', '--porcelain'],
    repository.path,
    'listWorkTrees'
  )

  const worktrees = new Array<LinkedWorkTree>()

  // the porcelain output from git-worktree covers multiple lines
  const listWorkTreeRe = /worktree (.*)\nHEAD ([a-f0-9]*)\n(branch .*|detached)\n/gm

  getMatches(result.stdout, listWorkTreeRe).forEach(m => {
    if (m.length === 4) {
      worktrees.push({
        path: m[1],
        head: m[2],
      })
    } else {
      log.debug(
        `[listWorkTrees] match '${
          m[0]
        }' does not have the expected data or output. Skipping...`
      )
    }
  })

  return worktrees
}

/**
 * Create a new work tree at the desired location on disk, checked
 * out to the given commit
 */
async function addWorkTree(
  repository: Repository,
  path: string,
  commit: string
): Promise<LinkedWorkTree> {
  await git(
    ['worktree', 'add', '-f', path, commit],
    repository.path,
    'addWorkTree'
  )

  // Because Git doesn't give enough information from stdout for the previous
  // Git call, this function enumerates the available worktrees to find the
  // expected worktree

  const workTrees = await listWorkTrees(repository)

  const directoryName = Path.basename(path)
  const workTree = workTrees.find(t => Path.basename(t.path) === directoryName)

  if (workTree == null) {
    throw new Error(
      `[addWorkTree] Unable to find created worktree at path ${path}`
    )
  }

  return workTree
}

/** Cleanup the temporary worktree at a given location */
export async function removeWorkTree(
  repository: Repository,
  path: string
): Promise<true> {
  await git(
    ['worktree', 'remove', '-f', path],
    repository.path,
    'removeWorkTree'
  )
  return true
}

const DesktopWorkTreePrefix = 'github-desktop-worktree-'

function getTemporaryDirectoryPrefix() {
  return Path.join(Os.tmpdir(), DesktopWorkTreePrefix)
}

async function findTemporaryWorkTrees(repository: Repository) {
  const workTrees = await listWorkTrees(repository)

  // always exclude the first entry as that will be "main" worktree and we
  // should not even look at it funny
  const candidateWorkTrees = workTrees.slice(1)

  return candidateWorkTrees.filter(t => {
    // NOTE:
    // we can't reliably check the full path here because Git seems to be
    // prefixing the temporary paths on macOS with a `/private` prefix, and
    // NodeJS doesn't seem to include this when we ask for the temporary
    // directory for the OS
    const directoryName = Path.basename(t.path)
    return directoryName.startsWith(DesktopWorkTreePrefix)
  })
}

/**
 * Finds an existing temporary work tree for use in Desktop or creates a new one.
 * Won't modify the repository's working directory.
 * _The returned worktree will be checked out to the given commit._
 */
export async function findOrCreateTemporaryWorkTree(
  repository: Repository,
  commit: string
): Promise<LinkedWorkTree> {
  const temporaryWorkTrees = await findTemporaryWorkTrees(repository)

  if (temporaryWorkTrees.length === 0) {
    const tmpdir = getTemporaryDirectoryPrefix()
    const directory = await FSE.mkdtemp(tmpdir)
    const workTree = await addWorkTree(repository, directory, commit)
    return workTree
  }

  const worktreeForDesktop = temporaryWorkTrees[0]

  await git(['checkout', commit], worktreeForDesktop.path, 'checkoutWorkTree')

  return worktreeForDesktop
}

/** Enumerate and cleanup any worktrees generated by Desktop */
export async function cleanupTemporaryWorkTrees(
  repository: Repository
): Promise<void> {
  const temporaryWorkTrees = await findTemporaryWorkTrees(repository)

  for (const worktree of temporaryWorkTrees) {
    await removeWorkTree(repository, worktree.path)
  }
}
